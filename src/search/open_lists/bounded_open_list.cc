#include "bounded_open_list.h"

#include "open_list.h"

#include "../option_parser.h"
#include "../plugin.h"

#include <set>

using namespace std;

template<class Entry>
class BoundedOpenList : public OpenList<Entry> {

    struct EntryComp {
        bool operator()(const pair<int, Entry> &left, const pair<int, Entry> &right) {
            return left.first < right.first;
        }
    };

    multiset<pair<int, Entry>, EntryComp> data;
    ScalarEvaluator *evaluator;
    const unsigned bound = 0;

protected:
    virtual void do_insertion(EvaluationContext &eval_context,
        const Entry &entry) override;
public:
    explicit BoundedOpenList(const Options &opts);
    BoundedOpenList(ScalarEvaluator * eval, bool preferred_only);
    virtual ~BoundedOpenList() override = default;

    virtual Entry remove_min(vector<int> *key = nullptr) override;
    virtual bool empty() const override;
    virtual void clear() override;
    virtual void get_involved_heuristics(set<Heuristic *> &hset) override;
    virtual bool is_dead_end(EvaluationContext &eval_context) const override;
    virtual bool is_reliable_dead_end(
        EvaluationContext &eval_context) const override;
};

template<class Entry>
BoundedOpenList<Entry>::BoundedOpenList(const Options &opts)
    : OpenList<Entry>(opts.get<bool>("pref_only")),
      evaluator(opts.get<ScalarEvaluator *>("eval")),
      bound(opts.get<int>("bound")) {
}

template<class Entry>
BoundedOpenList<Entry>::BoundedOpenList(ScalarEvaluator *evaluator,
    bool preferred_only)
    : OpenList<Entry>(preferred_only),
      evaluator(evaluator) {
}

template<class Entry>
void BoundedOpenList<Entry>::do_insertion(
    EvaluationContext &eval_context, const Entry &entry) {
    int h = eval_context.get_heuristic_value(evaluator);
    data.insert(make_pair(h, entry));
    if (data.size() > bound)
        data.erase(--data.end());
}

template<class Entry>
Entry BoundedOpenList<Entry>::remove_min(vector<int> *key) {
    assert(!data.empty());
    auto it = data.begin();

    if (key) {
        assert(key->empty());
        key->push_back(it->first);
    }

    Entry result = (*it).second;
    data.erase(it);
    return result;
}

template<class Entry>
bool BoundedOpenList<Entry>::empty() const {
    return data.empty();
}

template<class Entry>
void BoundedOpenList<Entry>::clear() {
    data.clear();
}

template<class Entry>
void BoundedOpenList<Entry>::get_involved_heuristics(
    set<Heuristic *> &hset) {
    evaluator->get_involved_heuristics(hset);
}

template<class Entry>
bool BoundedOpenList<Entry>::is_dead_end(
    EvaluationContext &eval_context) const {
    return eval_context.is_heuristic_infinite(evaluator);
}

template<class Entry>
bool BoundedOpenList<Entry>::is_reliable_dead_end(
    EvaluationContext &eval_context) const {
    return is_dead_end(eval_context) && evaluator->dead_ends_are_reliable();
}

BoundedOpenListFactory::BoundedOpenListFactory(const Options &options)
    : options(options) {
}


unique_ptr<StateOpenList>
BoundedOpenListFactory::create_state_open_list() {
    return utils::make_unique_ptr<BoundedOpenList<StateOpenListEntry>>(options);
}

unique_ptr<EdgeOpenList>
BoundedOpenListFactory::create_edge_open_list() {
    return utils::make_unique_ptr<BoundedOpenList<EdgeOpenListEntry>>(options);
}

static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {
    parser.document_synopsis(
        "Bounded length open list",
        "Bounded length open list using a single evaluator");
    parser.add_option<ScalarEvaluator *>("eval", "scalar evaluator");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<int>("bound",
        "the maximum number of states in the queue", "1000");

    Options opts = parser.parse();
    if (parser.dry_run())
        return nullptr;
    else
        return make_shared<BoundedOpenListFactory>(opts);
}

static PluginShared<OpenListFactory> _plugin("bounded", _parse);